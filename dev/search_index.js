var documenterSearchIndex = {"docs":
[{"location":"#Intervals-1","page":"Home","title":"Intervals","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using Intervals, Dates, TimeZones\nend\nDocTestFilters = [\n    r\"AnchoredInterval\\{(Day|Hour|Minute)\\(-\\d+\\),|HourEnding\\{\",\n    r\"AnchoredInterval\\{(Day|Hour|Minute)\\(\\d+\\),|HourBeginning\\{\",\n]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package defines:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AbstractInterval, along with its subtypes:\nInterval{T,L,R}, which represents a non-iterable range between two endpoints of type T with left/right bounds types respectively being L and R\nAnchoredInterval{P,T,L,R}, which represents a non-iterable range defined by a single value anchor::T and the value type P which represents the span of the range. Left/right bounds types are specifed by L and R respectively\nHourEnding, a type alias for AnchoredInterval{Hour(-1)}\nHourBeginning, a type alias for AnchoredInterval{Hour(1)}\nHE and HB, pseudoconstructors for HourEnding and HourBeginning that round the anchor up (HE) or down (HB) to the nearest hour\nBound, abstract type for all possible bounds type classifications:\nClosed, indicating the endpoint value of the interval is included\nOpen, indicating the endpoint value of the interval is not included\nUnbounded, indicating the endpoint value is effectively infinite","category":"page"},{"location":"#Example-Usage-1","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"#Intersection-1","page":"Home","title":"Intersection","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> a = 1..10\nInterval{Int64,Closed,Closed}(1, 10)\n\njulia> b = 5..15\nInterval{Int64,Closed,Closed}(5, 15)\n\njulia> intersect(a, b)\nInterval{Int64,Closed,Closed}(5, 10)","category":"page"},{"location":"#Bounds-1","page":"Home","title":"Bounds","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> a = Interval{Closed,Closed}(1, 10)\nInterval{Int64,Closed,Closed}(1, 10)\n\njulia> b = Interval{Open,Open}(5, 15)\nInterval{Int64,Open,Open}(5, 15)\n\njulia> 5 in a\ntrue\n\njulia> 5 in b\nfalse\n\njulia> intersect(a, b)\nInterval{Int64,Open,Closed}(5, 10)\n\njulia> c = Interval(15, 20)\nInterval{Int64,Closed,Closed}(15, 20)\n\njulia> isempty(intersect(b, c))\ntrue","category":"page"},{"location":"#Display-1","page":"Home","title":"Display","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> a = Interval('a', 'z')\nInterval{Char,Closed,Closed}('a', 'z')\n\njulia> string(a)\n\"[a .. z]\"\n\njulia> using Dates\n\njulia> b = Interval{Closed,Open}(Date(2013), Date(2016))\nInterval{Date,Closed,Open}(Date(\"2013-01-01\"), Date(\"2016-01-01\"))\n\njulia> string(b)\n\"[2013-01-01 .. 2016-01-01)\"\n\njulia> c = HourEnding(DateTime(2016, 8, 11))\nAnchoredInterval{Hour(-1),DateTime,Open,Closed}(DateTime(\"2016-08-11T00:00:00\"))\n\njulia> string(c)\n\"(2016-08-10 HE24]\"","category":"page"},{"location":"#HourEnding-and-HE-1","page":"Home","title":"HourEnding and HE","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> using TimeZones, Dates\n\njulia> unrounded = HourEnding(ZonedDateTime(2013, 2, 13, 0, 30, tz\"America/Winnipeg\"))\nAnchoredInterval{Hour(-1),ZonedDateTime,Open,Closed}(ZonedDateTime(2013, 2, 13, 0, 30, tz\"America/Winnipeg\"))\n\njulia> he = HE(ZonedDateTime(2013, 2, 13, 0, 30, tz\"America/Winnipeg\"))\nAnchoredInterval{Hour(-1),ZonedDateTime,Open,Closed}(ZonedDateTime(2013, 2, 13, 1, tz\"America/Winnipeg\"))\n\njulia> he + Hour(1)\nAnchoredInterval{Hour(-1),ZonedDateTime,Open,Closed}(ZonedDateTime(2013, 2, 13, 2, tz\"America/Winnipeg\"))\n\njulia> foreach(println, he:he + Day(1))\n(2013-02-13 HE01-06:00]\n(2013-02-13 HE02-06:00]\n(2013-02-13 HE03-06:00]\n(2013-02-13 HE04-06:00]\n(2013-02-13 HE05-06:00]\n(2013-02-13 HE06-06:00]\n(2013-02-13 HE07-06:00]\n(2013-02-13 HE08-06:00]\n(2013-02-13 HE09-06:00]\n(2013-02-13 HE10-06:00]\n(2013-02-13 HE11-06:00]\n(2013-02-13 HE12-06:00]\n(2013-02-13 HE13-06:00]\n(2013-02-13 HE14-06:00]\n(2013-02-13 HE15-06:00]\n(2013-02-13 HE16-06:00]\n(2013-02-13 HE17-06:00]\n(2013-02-13 HE18-06:00]\n(2013-02-13 HE19-06:00]\n(2013-02-13 HE20-06:00]\n(2013-02-13 HE21-06:00]\n(2013-02-13 HE22-06:00]\n(2013-02-13 HE23-06:00]\n(2013-02-13 HE24-06:00]\n(2013-02-14 HE01-06:00]\n\njulia> anchor(he)\n2013-02-13T01:00:00-06:00","category":"page"},{"location":"#Plotting-1","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"AbstractInterval subtypes can be plotted with Plots.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Plots\n\njulia> start_dt = DateTime(2017,1,1,0,0,0);\n\njulia> end_dt = DateTime(2017,1,1,10,30,0);\n\njulia> datetimes = start_dt:Hour(1):end_dt\nDateTime(\"2017-01-01T00:00:00\"):Hour(1):DateTime(\"2017-01-01T10:00:00\")\n\njulia> intervals = HE.(datetimes);\n\njulia> plot(intervals, 1:11)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Example Plot)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In the plot, inclusive boundaries are marked with a vertical bar, whereas exclusive boundaries just end.","category":"page"},{"location":"#Comparisons-1","page":"Home","title":"Comparisons","text":"","category":"section"},{"location":"#Equality-1","page":"Home","title":"Equality","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Two AbstractIntervals are considered equal if they have identical left and right endpoints (taking bounds into account):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> a = Interval{Closed,Open}(DateTime(2013, 2, 13), DateTime(2013, 2, 13, 1))\nInterval{DateTime,Closed,Open}(DateTime(\"2013-02-13T00:00:00\"), DateTime(\"2013-02-13T01:00:00\"))\n\njulia> b = Interval{Open,Closed}(DateTime(2013, 2, 13), DateTime(2013, 2, 13, 1))\nInterval{DateTime,Open,Closed}(DateTime(\"2013-02-13T00:00:00\"), DateTime(\"2013-02-13T01:00:00\"))\n\njulia> c = HourEnding(DateTime(2013, 2, 13, 1))\nAnchoredInterval{Hour(-1),DateTime,Open,Closed}(DateTime(\"2013-02-13T01:00:00\"))\n\njulia> a == b\nfalse\n\njulia> b == c\ntrue","category":"page"},{"location":"#Less-Than-1","page":"Home","title":"Less Than","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"When determining whether one AbstractInterval is less than (or greater than) another, two sets of comparison operators are available: </> and ≪/≫.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The standard < and > operators (which are not explicitly defined, but are derived from isless) simply compare the leftmost endpoint of the intervals, and are used for things like sort, min, max, etc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The ≪ and ≫ operators (the Unicode symbols for \"much less than\" and \"much greater than\", accessible from the REPL with \\ll and \\gg, respectively) are used in this context to mean \"less/greater than and disjoint\"; they will verify that there is no overlap between the intervals.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> 0..10 < 10..20\ntrue\n\njulia> 0..10 ≪ 10..20\nfalse\n\njulia> 0..10 ≪ 11..20\ntrue","category":"page"},{"location":"#API-1","page":"Home","title":"API","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Interval\nAnchoredInterval\nHourEnding\nHourBeginning\nHE\nHB\nBound\nIntervals.Bounded\nClosed\nOpen\nUnbounded\nfirst\nlast\nspan\nisclosed\nisopen\nIntervals.isunbounded\nIntervals.isbounded\nBase.parse(::Type{Interval{T}}, ::AbstractString) where T\n≪\n≫\n==\nunion\nunion!\nsuperset","category":"page"},{"location":"#Intervals.Interval","page":"Home","title":"Intervals.Interval","text":"Interval{T, L <: Bound, R <: Bound}\n\nAn Interval represents a non-iterable range or span of values (non-interable because, unlike a StepRange, no step is defined).\n\nAn Interval can be closed (both first and last are included in the interval), open (neither first nor last are included), or half-open. This openness is defined by the bounds information which is stored as the type parameters L and R.\n\nExample\n\njulia> interval = Interval{Closed,Open}(0, 100)\nInterval{Int64,Closed,Open}}(0, 100)\n\njulia> 0 in interval\ntrue\n\njulia> 50 in interval\ntrue\n\njulia> 100 in interval\nfalse\n\njulia> intersect(Interval{Open,Open}(0, 25), Interval{Closed,Closed}(20, 50)\nInterval{Int64,Closed,Open}(20, 25)\n\nInfix Constructor: ..\n\nA closed Interval can be constructed with the .. infix constructor:\n\njulia> Dates.today() - Dates.Week(1) .. Dates.today()\nInterval{Date,Closed,Closed}(2018-01-24, 2018-01-31)\n\nNote on Ordering\n\nThe Interval constructor will compare first and last; if it finds that first > last, they will be reversed to ensure that first < last. This simplifies calls to in and intersect:\n\njulia> i = Interval{Open,Closed}(Date(2016, 8, 11), Date(2013, 2, 13))\nInterval{Date,Closed,Open}(2013-02-13, 2016-08-11)\n\nNote that the bounds are also reversed in this case.\n\nSee also: AnchoredInterval\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.AnchoredInterval","page":"Home","title":"Intervals.AnchoredInterval","text":"AnchoredInterval{P,T,L,R}\n\nAnchoredInterval is a subtype of AbstractInterval that represents a non-iterable range or span of values defined not by two endpoints but instead by a single anchor point and the value type P which represents the size of the range. When P is positive, the anchor represents the lesser endpoint (the beginning of the range); when P is negative, the anchor represents the greater endpoint (the end of the range).\n\nThe interval represented by an AnchoredInterval value may be closed (both endpoints are included in the interval), open (neither endpoint is included), or half-open. This openness is defined by the bounds types L and R, which defaults to half-open (with the lesser endpoint included for positive values of P and the greater endpoint included for negative values).\n\nWhy?\n\nAnchoredIntervals are most useful in cases where a single value is used to stand in for a range of values. This happens most often with dates and times, where \"HE15\" is often used as shorthand for (14:00..15:00].\n\nTo this end, HourEnding is a type alias for AnchoredInterval{Hour(-1)}. Similarly, HourBeginning is a type alias for AnchoredInterval{Hour(1)}.\n\nRounding\n\nWhile the user may expect an HourEnding or HourBeginning value to be anchored to a specific hour, the constructor makes no guarantees that the anchor provided is rounded:\n\njulia> HourEnding(DateTime(2016, 8, 11, 2, 30))\nAnchoredInterval{Hour(-1),DateTime,Open,Closed}(DateTime(\"2016-08-11T02:30:00\"))\n\nThe HE and HB pseudoconstructors round the input up or down to the nearest hour, as appropriate:\n\njulia> HE(DateTime(2016, 8, 11, 2, 30))\nAnchoredInterval{Hour(-1),DateTime,Open,Closed}(DateTime(\"2016-08-11T03:00:00\"))\n\njulia> HB(DateTime(2016, 8, 11, 2, 30))\nAnchoredInterval{Hour(1),DateTime,Closed,Open}(DateTime(\"2016-08-11T02:00:00\"))\n\nExample\n\njulia> AnchoredInterval{Hour(-1)}(DateTime(2016, 8, 11, 12))\nAnchoredInterval{Hour(-1),DateTime,Open,Closed}(DateTime(\"2016-08-11T12:00:00\"))\n\njulia> AnchoredInterval{Day(1)}(DateTime(2016, 8, 11))\nAnchoredInterval{Day(1),DateTime,Closed,Open}(DateTime(\"2016-08-11T00:00:00\"))\n\njulia> AnchoredInterval{Minute(5),Closed,Closed}(DateTime(2016, 8, 11, 12, 30))\nAnchoredInterval{Minute(5),DateTime,Closed,Closed}(DateTime(\"2016-08-11T12:30:00\"))\n\nSee also: Interval, HE, HB\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.HourEnding","page":"Home","title":"Intervals.HourEnding","text":"HourEnding{T<:TimeType, L, R} <: AbstractInterval{T}\n\nA type alias for AnchoredInterval{Hour(-1), T} which is used to denote a 1-hour period of time which ends at a time instant (of type T).\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.HourBeginning","page":"Home","title":"Intervals.HourBeginning","text":"HourBeginning{T<:TimeType, L, R} <: AbstractInterval{T}\n\nA type alias for AnchoredInterval{Hour(1), T} which is used to denote a 1-hour period of time which begins at a time instant (of type T).\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.HE","page":"Home","title":"Intervals.HE","text":"HE(anchor) -> HourEnding\n\nHE is a pseudoconstructor for HourEnding that rounds the anchor provided up to the nearest hour.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.HB","page":"Home","title":"Intervals.HB","text":"HB(anchor) -> HourBeginning\n\nHB is a pseudoconstructor for HourBeginning that rounds the anchor provided down to the nearest hour.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.Bound","page":"Home","title":"Intervals.Bound","text":"Bound <: Any\n\nAbstract type representing all possible endpoint classifications (e.g. open, closed, unbounded).\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.Bounded","page":"Home","title":"Intervals.Bounded","text":"Bounded <: Bound\n\nAbstract type indicating that the endpoint of an interval is not unbounded (e.g. open or closed).\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.Closed","page":"Home","title":"Intervals.Closed","text":"Closed <: Bounded <: Bound\n\nType indicating that the endpoint of an interval is closed (the endpoint value is included in the interval).\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.Open","page":"Home","title":"Intervals.Open","text":"Open <: Bounded <: Bound\n\nType indicating that the endpoint of an interval is open (the endpoint value is not included in the interval).\n\n\n\n\n\n","category":"type"},{"location":"#Intervals.Unbounded","page":"Home","title":"Intervals.Unbounded","text":"Unbounded <: Bound\n\nType indicating that the endpoint of an interval is unbounded (the endpoint value is effectively infinite).\n\n\n\n\n\n","category":"type"},{"location":"#Base.first","page":"Home","title":"Base.first","text":"first(interval::AbstractInterval{T}) -> Union{T,Nothing}\n\nThe value of the lower endpoint. When the lower endpoint is unbounded nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"#Base.last","page":"Home","title":"Base.last","text":"last(interval::AbstractInterval{T}) -> Union{T,Nothing}\n\nThe value of the upper endpoint. When the upper endpoint is unbounded nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.span","page":"Home","title":"Intervals.span","text":"span(interval::AbstractInterval) -> Any\n\nThe delta between the upper and lower endpoints. For bounded intervals returns a non-negative value while intervals with any unbounded endpoints will throw an ArgumentError.\n\nTo avoid having to capture the exception use the pattern:\n\nIntervals.isbounded(interval) ? span(interval) : infinity\n\nWhere infinity is a variable representing the value you wish to use to represent an unbounded, or infinite, span.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.isclosed","page":"Home","title":"Intervals.isclosed","text":"isclosed(interval) -> Bool\n\nIs a closed-interval: includes both of its endpoints.\n\n\n\n\n\n","category":"function"},{"location":"#Base.isopen","page":"Home","title":"Base.isopen","text":"isopen(interval) -> Bool\n\nIs an open-interval: excludes both of its endpoints.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.isunbounded","page":"Home","title":"Intervals.isunbounded","text":"isunbounded(interval) -> Bool\n\nIs an unbounded-interval: unbounded at both ends.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.isbounded","page":"Home","title":"Intervals.isbounded","text":"isbounded(interval) -> Bool\n\nIs a bounded-interval: either open, closed, left-closed/right-open, or left-open/right-closed.\n\nNote using !isbounded is commonly used to determine if any end of the interval is unbounded.\n\n\n\n\n\n","category":"function"},{"location":"#Base.parse-Union{Tuple{T}, Tuple{Type{Interval{T,L,R} where R<:Bound where L<:Bound},AbstractString}} where T","page":"Home","title":"Base.parse","text":"parse(::Type{Interval{T}}, str; element_parser=parse) -> Interval{T}\n\nParse a string of the form <left-type><left-value><delim><right-value><right-type> (e.g. [1 .. 2)) as an Interval{T}. The format above is interpreted as:\n\nleft-type: Must be either \"[\" or \"(\" which indicates if the left-endpoint of the interval is either Closed or Open.\nleft-value: Specifies the value of the left-endpoint which will be parsed as the type T. If the value string has a length of zero then the left-endpoint will be specified as Unbounded. If the value string contains the delimiter (see below) then you may double-quote the value string to avoid any ambiguity.\ndelim: Must be either \"..\" or \",\" which indicates the delimiter separating the left/right endpoint values.\nright-value: Specifies the value of the right-endpoint. See left-value for more details.\nright-type: Must be either \"]\" or \")\" which indicates if the right-endpoint of the  interval is either Closed or Open.\n\nThe element_parser keyword allows a custom parser to be used when parsing the left/right values. The function is expected to take two arguments: Type{T} and AbstractString. This is useful for supplying additional arguments/keywords, alternative parser functions, or for types that do not define parse (e.g. String).\n\n\n\n\n\n","category":"method"},{"location":"#Intervals.:≪","page":"Home","title":"Intervals.:≪","text":"≪(a::AbstractInterval, b::AbstractInterval) -> Bool\nless_than_disjoint(a::AbstractInterval, b::AbstractInterval) -> Bool\n\nLess-than-and-disjoint comparison operator. Returns true if a is less than b and they are disjoint (they do not overlap).\n\njulia> 0..10 ≪ 10..20\nfalse\n\njulia> 0..10 ≪ 11..20\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.:≫","page":"Home","title":"Intervals.:≫","text":"≫(a::AbstractInterval, b::AbstractInterval) -> Bool\ngreater_than_disjoint(a::AbstractInterval, b::AbstractInterval) -> Bool\n\nGreater-than-and-disjoint comparison operator. Returns true if a is greater than b and they are disjoint (they do not overlap).\n\njulia> 10..20 ≫ 0..10\nfalse\n\njulia> 11..20 ≫ 0..10\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Base.:==","page":"Home","title":"Base.:==","text":"==(a::Endpoint, b::Endpoint) -> Bool\n\nDetermine if two endpoints are equal. When both endpoints are left or right then the points and inclusiveness must be the same.\n\nChecking the equality of left-endpoint and a right-endpoint is slightly more difficult. A left-endpoint and a right-endpoint are only equal when they use the same point and are both included. Note that left/right endpoints which are both not included are not equal as the left-endpoint contains values below that point while the right-endpoint only contains values that are above that point.\n\nVisualizing two contiguous intervals can assist in understanding this logic:\n\n[x..y][y..z] -> RightEndpoint == LeftEndpoint\n[x..y)[y..z] -> RightEndpoint != LeftEndpoint\n[x..y](y..z] -> RightEndpoint != LeftEndpoint\n[x..y)(y..z] -> RightEndpoint != LeftEndpoint\n\n\n\n\n\n","category":"function"},{"location":"#Base.union","page":"Home","title":"Base.union","text":"union(intervals::AbstractVector{<:AbstractInterval})\n\nFlattens a vector of overlapping intervals into a new, smaller vector containing only non-overlapping intervals.\n\n\n\n\n\n","category":"function"},{"location":"#Base.union!","page":"Home","title":"Base.union!","text":"union!(intervals::AbstractVector{<:Union{Interval, AbstractInterval}})\n\nFlattens a vector of overlapping intervals in-place to be a smaller vector containing only non-overlapping intervals.\n\n\n\n\n\n","category":"function"},{"location":"#Intervals.superset","page":"Home","title":"Intervals.superset","text":"superset(intervals::AbstractArray{<:AbstractInterval}) -> Interval\n\nCreate the smallest single interval which encompasses all of the provided intervals.\n\n\n\n\n\n","category":"function"}]
}
