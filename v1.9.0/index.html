<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Intervals.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img class="docs-light-only" src="assets/logo.png" alt="Intervals.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Intervals.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Intervals.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Sets-1"><span>Sets</span></a></li><li><a class="tocitem" href="#Example-Usage-1"><span>Example Usage</span></a></li><li><a class="tocitem" href="#API-1"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/invenia/Intervals.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Intervals-1"><a class="docs-heading-anchor" href="#Intervals-1">Intervals</a><a class="docs-heading-anchor-permalink" href="#Intervals-1" title="Permalink"></a></h1><p>This package defines:</p><ul><li><code>AbstractInterval</code>, along with its subtypes:<ul><li><a href="#Intervals.Interval"><code>Interval{T,L,R}</code></a>, which represents a non-iterable range between two endpoints of type <code>T</code> with left/right bounds types respectively being <code>L</code> and <code>R</code></li><li><a href="#Intervals.AnchoredInterval"><code>AnchoredInterval{P,T,L,R}</code></a>, which represents a non-iterable range defined by a single value <code>anchor::T</code> and the value type <code>P</code> which represents the span of the range. Left/right bounds types are specifed by <code>L</code> and <code>R</code> respectively<ul><li><a href="#Intervals.HourEnding"><code>HourEnding</code></a>, a type alias for <code>AnchoredInterval{Hour(-1)}</code></li><li><a href="#Intervals.HourBeginning"><code>HourBeginning</code></a>, a type alias for <code>AnchoredInterval{Hour(1)}</code></li><li><a href="#Intervals.HE"><code>HE</code></a> and <a href="#Intervals.HB"><code>HB</code></a>, pseudoconstructors for <code>HourEnding</code> and <code>HourBeginning</code> that round the anchor up (<code>HE</code>) or down (<code>HB</code>) to the nearest hour</li></ul></li></ul></li><li><a href="#Intervals.Bound"><code>Bound</code></a>, abstract type for all possible bounds type classifications:<ul><li><a href="#Intervals.Closed"><code>Closed</code></a>, indicating the endpoint value of the interval is included</li><li><a href="#Intervals.Open"><code>Open</code></a>, indicating the endpoint value of the interval is not included</li><li><a href="#Intervals.Unbounded"><code>Unbounded</code></a>, indicating the endpoint value is effectively infinite</li></ul></li></ul><h2 id="Sets-1"><a class="docs-heading-anchor" href="#Sets-1">Sets</a><a class="docs-heading-anchor-permalink" href="#Sets-1" title="Permalink"></a></h2><p>A single interval can be used to represent a contiguous set within a domain but cannot be used to represent a disjoint set. For general purpose set operations you need to use the <code>IntervalSet</code> type.</p><article class="docstring"><header><a class="docstring-binding" id="Intervals.IntervalSet" href="#Intervals.IntervalSet"><code>Intervals.IntervalSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IntervalSet{T&lt;:AbstractInterval}</code></pre><p>A set of points represented by a sequence of intervals. Set operations over interval sets return a new IntervalSet, with the fewest number of intervals possible. Unbounded intervals are not supported. The individual intervals in the set can be accessed by calling <code>convert(Array, interval_set)</code>.</p><p>see also: https://en.wikipedia.org/wiki/Interval<em>arithmetic#Interval</em>operators</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; union(IntervalSet(1..5), IntervalSet(3..8))
1-interval IntervalSet{Interval{Int64, Closed, Closed}}:
[1 .. 8]

julia&gt; intersect(IntervalSet(1..5), IntervalSet(3..8))
1-interval IntervalSet{Interval{Int64, Closed, Closed}}:
[3 .. 5]

julia&gt; symdiff(IntervalSet(1..5), IntervalSet(3..8))
2-interval IntervalSet{Interval{Int64, L, R} where {L&lt;:Bound, R&lt;:Bound}}:
[1 .. 3)
(5 .. 8]

julia&gt; union(IntervalSet([1..2, 2..5]), IntervalSet(6..7))
2-interval IntervalSet{Interval{Int64, Closed, Closed}}:
[1 .. 5]
[6 .. 7]

julia&gt; union(IntervalSet([1..5, 8..10]), IntervalSet([4..9, 12..14]))
2-interval IntervalSet{Interval{Int64, Closed, Closed}}:
[1 .. 10]
[12 .. 14]

julia&gt; intersect(IntervalSet([1..5, 8..10]), IntervalSet([4..9, 12..14]))
2-interval IntervalSet{Interval{Int64, Closed, Closed}}:
[4 .. 5]
[8 .. 9]

julia&gt; setdiff(IntervalSet([1..5, 8..10]), IntervalSet([4..9, 12..14]))
2-interval IntervalSet{Interval{Int64, L, R} where {L&lt;:Bound, R&lt;:Bound}}:
[1 .. 4)
(9 .. 10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval_sets.jl#LL3-L49">source</a></section></article><p>If you wish to instead treat each interval as an <em>element</em> of a set, you can operate over vectors or <code>Set</code>s of intervals.</p><p>For example:</p><pre><code class="language-julia">julia&gt; intersect([1..2, 2..3, 3..4, 4..5], [2..3, 3..4])
2-element Vector{Interval{Int64, Closed, Closed}}:
 Interval{Int64, Closed, Closed}(2, 3)
 Interval{Int64, Closed, Closed}(3, 4)</code></pre><h2 id="Example-Usage-1"><a class="docs-heading-anchor" href="#Example-Usage-1">Example Usage</a><a class="docs-heading-anchor-permalink" href="#Example-Usage-1" title="Permalink"></a></h2><h3 id="Bounds-1"><a class="docs-heading-anchor" href="#Bounds-1">Bounds</a><a class="docs-heading-anchor-permalink" href="#Bounds-1" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; a = Interval{Closed, Closed}(1, 10)
Interval{Int64, Closed, Closed}(1, 10)

julia&gt; b = Interval{Open, Open}(5, 15)
Interval{Int64, Open, Open}(5, 15)

julia&gt; 5 in a
true

julia&gt; 5 in b
false

julia&gt; intersect(a, b)
Interval{Int64, Open, Closed}(5, 10)

julia&gt; c = Interval(15, 20)
Interval{Int64, Closed, Closed}(15, 20)

julia&gt; isempty(intersect(b, c))
true</code></pre><h3 id="Display-1"><a class="docs-heading-anchor" href="#Display-1">Display</a><a class="docs-heading-anchor-permalink" href="#Display-1" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; a = Interval(&#39;a&#39;, &#39;z&#39;)
Interval{Char, Closed, Closed}(&#39;a&#39;, &#39;z&#39;)

julia&gt; string(a)
&quot;[a .. z]&quot;

julia&gt; using Dates

julia&gt; b = Interval{Closed, Open}(Date(2013), Date(2016))
Interval{Date, Closed, Open}(Date(&quot;2013-01-01&quot;), Date(&quot;2016-01-01&quot;))

julia&gt; string(b)
&quot;[2013-01-01 .. 2016-01-01)&quot;

julia&gt; c = HourEnding(DateTime(2016, 8, 11))
HourEnding{DateTime, Open, Closed}(DateTime(&quot;2016-08-11T00:00:00&quot;))

julia&gt; string(c)
&quot;(2016-08-10 HE24]&quot;</code></pre><h3 id="HourEnding-and-HE-1"><a class="docs-heading-anchor" href="#HourEnding-and-HE-1"><code>HourEnding</code> and <code>HE</code></a><a class="docs-heading-anchor-permalink" href="#HourEnding-and-HE-1" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; using TimeZones, Dates

julia&gt; unrounded = HourEnding(ZonedDateTime(2013, 2, 13, 0, 30, tz&quot;America/Winnipeg&quot;))
HourEnding{ZonedDateTime, Open, Closed}(ZonedDateTime(2013, 2, 13, 0, 30, tz&quot;America/Winnipeg&quot;))

julia&gt; he = HE(ZonedDateTime(2013, 2, 13, 0, 30, tz&quot;America/Winnipeg&quot;))
HourEnding{ZonedDateTime, Open, Closed}(ZonedDateTime(2013, 2, 13, 1, tz&quot;America/Winnipeg&quot;))

julia&gt; he + Hour(1)
HourEnding{ZonedDateTime, Open, Closed}(ZonedDateTime(2013, 2, 13, 2, tz&quot;America/Winnipeg&quot;))

julia&gt; foreach(println, he:he + Day(1))
(2013-02-13 HE01-06:00]
(2013-02-13 HE02-06:00]
(2013-02-13 HE03-06:00]
(2013-02-13 HE04-06:00]
(2013-02-13 HE05-06:00]
(2013-02-13 HE06-06:00]
(2013-02-13 HE07-06:00]
(2013-02-13 HE08-06:00]
(2013-02-13 HE09-06:00]
(2013-02-13 HE10-06:00]
(2013-02-13 HE11-06:00]
(2013-02-13 HE12-06:00]
(2013-02-13 HE13-06:00]
(2013-02-13 HE14-06:00]
(2013-02-13 HE15-06:00]
(2013-02-13 HE16-06:00]
(2013-02-13 HE17-06:00]
(2013-02-13 HE18-06:00]
(2013-02-13 HE19-06:00]
(2013-02-13 HE20-06:00]
(2013-02-13 HE21-06:00]
(2013-02-13 HE22-06:00]
(2013-02-13 HE23-06:00]
(2013-02-13 HE24-06:00]
(2013-02-14 HE01-06:00]

julia&gt; anchor(he)
2013-02-13T01:00:00-06:00</code></pre><h3 id="Comparisons-1"><a class="docs-heading-anchor" href="#Comparisons-1">Comparisons</a><a class="docs-heading-anchor-permalink" href="#Comparisons-1" title="Permalink"></a></h3><h4 id="Equality-1"><a class="docs-heading-anchor" href="#Equality-1">Equality</a><a class="docs-heading-anchor-permalink" href="#Equality-1" title="Permalink"></a></h4><p>Two <code>AbstractInterval</code>s are considered equal if they have identical left and right endpoints (taking bounds into account):</p><pre><code class="language-julia-repl">julia&gt; a = Interval{Closed, Open}(DateTime(2013, 2, 13), DateTime(2013, 2, 13, 1))
Interval{DateTime, Closed, Open}(DateTime(&quot;2013-02-13T00:00:00&quot;), DateTime(&quot;2013-02-13T01:00:00&quot;))

julia&gt; b = Interval{Open, Closed}(DateTime(2013, 2, 13), DateTime(2013, 2, 13, 1))
Interval{DateTime, Open, Closed}(DateTime(&quot;2013-02-13T00:00:00&quot;), DateTime(&quot;2013-02-13T01:00:00&quot;))

julia&gt; c = HourEnding(DateTime(2013, 2, 13, 1))
HourEnding{DateTime, Open, Closed}(DateTime(&quot;2013-02-13T01:00:00&quot;))

julia&gt; a == b
false

julia&gt; b == c
true</code></pre><h4 id="Less-Than-1"><a class="docs-heading-anchor" href="#Less-Than-1">Less Than</a><a class="docs-heading-anchor-permalink" href="#Less-Than-1" title="Permalink"></a></h4><p>When determining whether one <code>AbstractInterval</code> is less than (or greater than) another, two sets of comparison operators are available: <code>&lt;</code>/<code>&gt;</code> and <code>≪</code>/<code>≫</code>.</p><p>The standard <code>&lt;</code> and <code>&gt;</code> operators (which are not explicitly defined, but are derived from <code>isless</code>) simply compare the leftmost endpoint of the intervals, and are used for things like <code>sort</code>, <code>min</code>, <code>max</code>, etc.</p><p>The <code>≪</code> and <code>≫</code> operators (the Unicode symbols for &quot;much less than&quot; and &quot;much greater than&quot;, accessible from the REPL with <code>\ll</code> and <code>\gg</code>, respectively) are used in this context to mean &quot;less/greater than and disjoint&quot;; they will verify that there is no overlap between the intervals.</p><pre><code class="language-julia-repl">julia&gt; 0..10 &lt; 10..20
true

julia&gt; 0..10 ≪ 10..20
false

julia&gt; 0..10 ≪ 11..20
true</code></pre><h3 id="Rounding-1"><a class="docs-heading-anchor" href="#Rounding-1">Rounding</a><a class="docs-heading-anchor-permalink" href="#Rounding-1" title="Permalink"></a></h3><p>Interval rounding maintains the original span of the interval, shifting it according to whichever endpoint is specified as the one to use for rounding. The operations <code>floor</code>, <code>ceil</code>, and <code>round</code> are supported, as long as the <code>on</code> keyword is supplied to specify which endpoint should be used for rounding. Valid options are <code>:left</code>, <code>:right</code>, or <code>:anchor</code> if dealing with anchored intervals.</p><pre><code class="language-julia-repl">julia&gt; floor(Interval(0.0, 1.0), on=:left)
Interval{Float64, Closed, Closed}(0.0, 1.0)

julia&gt; floor(Interval(0.5, 1.0), on=:left)
Interval{Float64, Closed, Closed}(0.0, 0.5)

julia&gt; floor(Interval(0.5, 1.5), on=:right)
Interval{Float64, Closed, Closed}(0.0, 1.0)</code></pre><p>Anchored intervals default to rounding using the anchor point.</p><pre><code class="language-julia-repl">julia&gt; round(AnchoredInterval{-0.5}(1.0))
AnchoredInterval{-0.5, Float64, Open, Closed}(1.0)

julia&gt; round(AnchoredInterval{+0.5}(0.5))
AnchoredInterval{0.5, Float64, Closed, Open}(0.0)

julia&gt; round(AnchoredInterval{+0.5}(0.5), on=:anchor)
AnchoredInterval{0.5, Float64, Closed, Open}(0.0)

julia&gt; round(AnchoredInterval{+0.5}(0.5), on=:left)
AnchoredInterval{0.5, Float64, Closed, Open}(0.0)

julia&gt; round(AnchoredInterval{+0.5}(0.5), on=:right)
AnchoredInterval{0.5, Float64, Closed, Open}(0.5)</code></pre><h3 id="Plotting-1"><a class="docs-heading-anchor" href="#Plotting-1">Plotting</a><a class="docs-heading-anchor-permalink" href="#Plotting-1" title="Permalink"></a></h3><p><code>AbstractInterval</code> subtypes can be plotted with <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</p><pre><code class="language-julia">julia&gt; using Plots

julia&gt; start_dt = DateTime(2017,1,1,0,0,0);

julia&gt; end_dt = DateTime(2017,1,1,10,30,0);

julia&gt; datetimes = start_dt:Hour(1):end_dt
DateTime(&quot;2017-01-01T00:00:00&quot;):Hour(1):DateTime(&quot;2017-01-01T10:00:00&quot;)

julia&gt; intervals = HE.(datetimes);

julia&gt; plot(intervals, 1:11)</code></pre><p><img src="assets/HE.png" alt="Example Plot"/></p><p>In the plot, inclusive boundaries are marked with a vertical bar, whereas exclusive boundaries just end.</p><h2 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Intervals.Interval" href="#Intervals.Interval"><code>Intervals.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Interval{T, L &lt;: Bound, R &lt;: Bound}</code></pre><p>An <code>Interval</code> represents a non-iterable range or span of values (non-iterable because, unlike a <code>StepRange</code>, no step is defined).</p><p>An <code>Interval</code> can be closed (both <code>first</code> and <code>last</code> are included in the interval), open (neither <code>first</code> nor <code>last</code> are included), or half-open. This openness is defined by the bounds information which is stored as the type parameters <code>L</code> and <code>R</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; interval = Interval{Closed,Open}(0, 100)
Interval{Int64,Closed,Open}}(0, 100)

julia&gt; 0 in interval
true

julia&gt; 50 in interval
true

julia&gt; 100 in interval
false

julia&gt; intersect(Interval{Open,Open}(0, 25), Interval{Closed,Closed}(20, 50)
Interval{Int64,Closed,Open}(20, 25)</code></pre><p><strong>Infix Constructor: <code>..</code></strong></p><p>A closed <code>Interval</code> can be constructed with the <code>..</code> infix constructor:</p><pre><code class="language-julia">julia&gt; Dates.today() - Dates.Week(1) .. Dates.today()
Interval{Date,Closed,Closed}(2018-01-24, 2018-01-31)</code></pre><p>See also: <a href="#Intervals.AnchoredInterval"><code>AnchoredInterval</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval.jl#LL1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.AnchoredInterval" href="#Intervals.AnchoredInterval"><code>Intervals.AnchoredInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnchoredInterval{P,T,L,R}</code></pre><p><code>AnchoredInterval</code> is a subtype of <code>AbstractInterval</code> that represents a non-iterable range or span of values defined not by two endpoints but instead by a single <code>anchor</code> point and the value type <code>P</code> which represents the size of the range. When <code>P</code> is positive, the <code>anchor</code> represents the lesser endpoint (the beginning of the range); when <code>P</code> is negative, the <code>anchor</code> represents the greater endpoint (the end of the range).</p><p>The interval represented by an <code>AnchoredInterval</code> value may be closed (both endpoints are included in the interval), open (neither endpoint is included), or half-open. This openness is defined by the bounds types <code>L</code> and <code>R</code>, which defaults to half-open (with the lesser endpoint included for positive values of <code>P</code> and the greater endpoint included for negative values).</p><p><strong>Why?</strong></p><p><code>AnchoredIntervals</code> are most useful in cases where a single value is used to stand in for a range of values. This happens most often with dates and times, where &quot;HE15&quot; is often used as shorthand for (14:00..15:00].</p><p>To this end, <code>HourEnding</code> is a type alias for <code>AnchoredInterval{Hour(-1)}</code>. Similarly, <code>HourBeginning</code> is a type alias for <code>AnchoredInterval{Hour(1)}</code>.</p><p><strong>Rounding</strong></p><p>While the user may expect an <code>HourEnding</code> or <code>HourBeginning</code> value to be anchored to a specific hour, the constructor makes no guarantees that the anchor provided is rounded:</p><pre><code class="language-julia-repl">julia&gt; HourEnding(DateTime(2016, 8, 11, 2, 30))
HourEnding{DateTime, Open, Closed}(DateTime(&quot;2016-08-11T02:30:00&quot;))</code></pre><p>The <code>HE</code> and <code>HB</code> pseudoconstructors round the input up or down to the nearest hour, as appropriate:</p><pre><code class="language-julia-repl">julia&gt; HE(DateTime(2016, 8, 11, 2, 30))
HourEnding{DateTime, Open, Closed}(DateTime(&quot;2016-08-11T03:00:00&quot;))

julia&gt; HB(DateTime(2016, 8, 11, 2, 30))
HourBeginning{DateTime, Closed, Open}(DateTime(&quot;2016-08-11T02:00:00&quot;))</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; AnchoredInterval{Hour(-1)}(DateTime(2016, 8, 11, 12))
HourEnding{DateTime, Open, Closed}(DateTime(&quot;2016-08-11T12:00:00&quot;))

julia&gt; AnchoredInterval{Day(1)}(DateTime(2016, 8, 11))
AnchoredInterval{Day(1), DateTime, Closed, Open}(DateTime(&quot;2016-08-11T00:00:00&quot;))

julia&gt; AnchoredInterval{Minute(5),Closed,Closed}(DateTime(2016, 8, 11, 12, 30))
AnchoredInterval{Minute(5), DateTime, Closed, Closed}(DateTime(&quot;2016-08-11T12:30:00&quot;))</code></pre><p>See also: <a href="#Intervals.Interval"><code>Interval</code></a>, <a href="#Intervals.HE"><code>HE</code></a>, <a href="#Intervals.HB"><code>HB</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/anchoredinterval.jl#LL1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.HourEnding" href="#Intervals.HourEnding"><code>Intervals.HourEnding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HourEnding{T&lt;:TimeType, L, R} &lt;: AbstractInterval{T}</code></pre><p>A type alias for <code>AnchoredInterval{Hour(-1), T}</code> which is used to denote a 1-hour period of time which ends at a time instant (of type <code>T</code>).</p><p>When constructing an instance of <code>HourEnding{T}</code> the resulting interval will right-closed (of type <code>HourEnding{T,Open,Closed}</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/anchoredinterval.jl#LL114-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.HourBeginning" href="#Intervals.HourBeginning"><code>Intervals.HourBeginning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HourBeginning{T&lt;:TimeType, L, R} &lt;: AbstractInterval{T}</code></pre><p>A type alias for <code>AnchoredInterval{Hour(1), T}</code> which is used to denote a 1-hour period of time which begins at a time instant (of type <code>T</code>).</p><p>When constructing an instance of <code>HourBeginning{T}</code> the resulting interval will left-closed (of type <code>HourBeginning{T,Closed,Open}</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/anchoredinterval.jl#LL128-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.HE" href="#Intervals.HE"><code>Intervals.HE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HE(anchor) -&gt; HourEnding</code></pre><p><code>HE</code> is a pseudoconstructor for <a href="#Intervals.HourEnding"><code>HourEnding</code></a> that rounds the anchor provided up to the nearest hour.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/anchoredinterval.jl#LL140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.HB" href="#Intervals.HB"><code>Intervals.HB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HB(anchor) -&gt; HourBeginning</code></pre><p><code>HB</code> is a pseudoconstructor for <a href="#Intervals.HourBeginning"><code>HourBeginning</code></a> that rounds the anchor provided down to the nearest hour.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/anchoredinterval.jl#LL148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.Bound" href="#Intervals.Bound"><code>Intervals.Bound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bound &lt;: Any</code></pre><p>Abstract type representing all possible endpoint classifications (e.g. open, closed, unbounded).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.Bounded" href="#Intervals.Bounded"><code>Intervals.Bounded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bounded &lt;: Bound</code></pre><p>Abstract type indicating that the endpoint of an interval is not unbounded (e.g. open or closed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.Closed" href="#Intervals.Closed"><code>Intervals.Closed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Closed &lt;: Bounded &lt;: Bound</code></pre><p>Type indicating that the endpoint of an interval is closed (the endpoint value is <em>included</em> in the interval).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.Open" href="#Intervals.Open"><code>Intervals.Open</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Open &lt;: Bounded &lt;: Bound</code></pre><p>Type indicating that the endpoint of an interval is open (the endpoint value is <em>not included</em> in the interval).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.Unbounded" href="#Intervals.Unbounded"><code>Intervals.Unbounded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Unbounded &lt;: Bound</code></pre><p>Type indicating that the endpoint of an interval is unbounded (the endpoint value is effectively infinite).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">first(interval::AbstractInterval{T}) -&gt; Union{T,Nothing}</code></pre><p>The value of the lower endpoint. When the lower endpoint is unbounded <code>nothing</code> will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">last(interval::AbstractInterval{T}) -&gt; Union{T,Nothing}</code></pre><p>The value of the upper endpoint. When the upper endpoint is unbounded <code>nothing</code> will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.span" href="#Intervals.span"><code>Intervals.span</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">span(interval::AbstractInterval) -&gt; Any</code></pre><p>The delta between the upper and lower endpoints. For bounded intervals returns a non-negative value while intervals with any unbounded endpoints will throw an <code>ArgumentError</code>.</p><p>To avoid having to capture the exception use the pattern:</p><pre><code class="language-julia">Intervals.isbounded(interval) ? span(interval) : infinity</code></pre><p>Where <code>infinity</code> is a variable representing the value you wish to use to represent an unbounded, or infinite, span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.isclosed" href="#Intervals.isclosed"><code>Intervals.isclosed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isclosed(interval) -&gt; Bool</code></pre><p>Is a closed-interval: includes both of its endpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isopen" href="#Base.isopen"><code>Base.isopen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isopen(interval) -&gt; Bool</code></pre><p>Is an open-interval: excludes both of its endpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.isunbounded" href="#Intervals.isunbounded"><code>Intervals.isunbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isunbounded(interval) -&gt; Bool</code></pre><p>Is an unbounded-interval: unbounded at both ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.isbounded" href="#Intervals.isbounded"><code>Intervals.isbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbounded(interval) -&gt; Bool</code></pre><p>Is a bounded-interval: either open, closed, left-closed/right-open, or left-open/right-closed.</p><p>Note using <code>!isbounded</code> is commonly used to determine if any end of the interval is unbounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/docstrings.jl#LL155-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Union{Tuple{T}, Tuple{Type{Interval{T, L, R} where {L&lt;:Bound, R&lt;:Bound}}, AbstractString}} where T" href="#Base.parse-Union{Tuple{T}, Tuple{Type{Interval{T, L, R} where {L&lt;:Bound, R&lt;:Bound}}, AbstractString}} where T"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse(::Type{Interval{T}}, str; element_parser=parse) -&gt; Interval{T}</code></pre><p>Parse a string of the form <code>&lt;left-type&gt;&lt;left-value&gt;&lt;delim&gt;&lt;right-value&gt;&lt;right-type&gt;</code> (e.g. <code>[1 .. 2)</code>) as an <code>Interval{T}</code>. The format above is interpreted as:</p><ul><li><p><code>left-type</code>: Must be either &quot;[&quot; or &quot;(&quot; which indicates if the left-endpoint of the interval is either <code>Closed</code> or <code>Open</code>.</p></li><li><p><code>left-value</code>: Specifies the value of the left-endpoint which will be parsed as the type <code>T</code>. If the value string has a length of zero then the left-endpoint will be specified as <code>Unbounded</code>. If the value string contains the delimiter (see below) then you may double-quote the value string to avoid any ambiguity.</p></li><li><p><code>delim</code>: Must be either &quot;..&quot; or &quot;,&quot; which indicates the delimiter separating the left/right endpoint values.</p></li><li><p><code>right-value</code>: Specifies the value of the right-endpoint. See <code>left-value</code> for more details.</p></li><li><p><code>right-type</code>: Must be either &quot;]&quot; or &quot;)&quot; which indicates if the right-endpoint of the  interval is either <code>Closed</code> or <code>Open</code>.</p></li></ul><p>The <code>element_parser</code> keyword allows a custom parser to be used when parsing the left/right values. The function is expected to take two arguments: <code>Type{T}</code> and <code>AbstractString</code>. This is useful for supplying additional arguments/keywords, alternative parser functions, or for types that do not define <code>parse</code> (e.g. <code>String</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/parse.jl#LL17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.:≪" href="#Intervals.:≪"><code>Intervals.:≪</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">≪(a::AbstractInterval, b::AbstractInterval) -&gt; Bool
less_than_disjoint(a::AbstractInterval, b::AbstractInterval) -&gt; Bool</code></pre><p>Less-than-and-disjoint comparison operator. Returns <code>true</code> if <code>a</code> is less than <code>b</code> and they are disjoint (they do not overlap).</p><pre><code class="language-none">julia&gt; 0..10 ≪ 10..20
false

julia&gt; 0..10 ≪ 11..20
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval.jl#LL318-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.:≫" href="#Intervals.:≫"><code>Intervals.:≫</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">≫(a::AbstractInterval, b::AbstractInterval) -&gt; Bool
greater_than_disjoint(a::AbstractInterval, b::AbstractInterval) -&gt; Bool</code></pre><p>Greater-than-and-disjoint comparison operator. Returns <code>true</code> if <code>a</code> is greater than <code>b</code> and they are disjoint (they do not overlap).</p><pre><code class="language-none">julia&gt; 10..20 ≫ 0..10
false

julia&gt; 11..20 ≫ 0..10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval.jl#LL336-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">==(a::Endpoint, b::Endpoint) -&gt; Bool</code></pre><p>Determine if two endpoints are equal. When both endpoints are left or right then the points and inclusiveness must be the same.</p><p>Checking the equality of left-endpoint and a right-endpoint is slightly more difficult. A left-endpoint and a right-endpoint are only equal when they use the same point and are both included. Note that left/right endpoints which are both not included are not equal as the left-endpoint contains values below that point while the right-endpoint only contains values that are above that point.</p><p>Visualizing two contiguous intervals can assist in understanding this logic:</p><pre><code class="language-none">[x..y][y..z] -&gt; RightEndpoint == LeftEndpoint
[x..y)[y..z] -&gt; RightEndpoint != LeftEndpoint
[x..y](y..z] -&gt; RightEndpoint != LeftEndpoint
[x..y)(y..z] -&gt; RightEndpoint != LeftEndpoint</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/endpoint.jl#LL61-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">union(intervals::IntervalSets)</code></pre><p>Flattens any overlapping intervals within the <code>IntervalSet</code> into a new, smaller set containing only non-overlapping intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval_sets.jl#LL370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union!" href="#Base.union!"><code>Base.union!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">union!(intervals::IntervalSet)</code></pre><p>Flattens a vector of overlapping intervals in-place to be a smaller vector containing only non-overlapping intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval_sets.jl#LL387-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.superset" href="#Intervals.superset"><code>Intervals.superset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">superset(intervals::IntervalSet) -&gt; Interval</code></pre><p>Create the smallest single interval which encompasses all of the provided intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval_sets.jl#LL419-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Intervals.find_intersections" href="#Intervals.find_intersections"><code>Intervals.find_intersections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_intersections(
    x::AbstractVector{&lt;:AbstractInterval},
    y::AbstractVector{&lt;:AbstractInterval}
)</code></pre><p>Returns a <code>Vector{Vector{Int}}</code> where the value at index <code>i</code> gives the indices to all intervals in <code>y</code> that intersect with <code>x[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Intervals.jl/blob/ba938f6b45e4dae267434fd6f3d41008eeccbf84/src/interval_sets.jl#LL471-L479">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 25 January 2023 23:26">Wednesday 25 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
